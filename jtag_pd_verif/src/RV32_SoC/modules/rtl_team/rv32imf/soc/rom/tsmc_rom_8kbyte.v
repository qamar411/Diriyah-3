//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.  
//  and TSMC.                                                          
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less than a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Built for linux64 and running on linux64.                          
//                                                                     
//  Software           : Rev: W-2025.03                                
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : ts18s1p10v2sb02p2                             
//  Platform           : Linux4.18.0-553.54.1.el8_10.x86_64            
//                     : #1 SMP Sat May 17 16:41:33 EDT 2025x86_64     
//  Date of Generation : Mon Jun 30 19:46:12 PKT 2025                  
//                                                                     
//---------------------------------------------------------------------
//   --------------------------------------------------------------     
//                       Template Revision : 2.0.4                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port ROM *                   
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:tsmc_rom_8kbyte                                      
//   Memory Size:8192 words x 32 bits                                 
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[31:0]                          
//               Input Ports:                                         
//                                   ADR[12:0]                        
//                                   OE                               
//                                   ME                               
//                                   CLK                              


`resetall 

`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 
`delay_mode_path 


`define True    1'b1
`define False   1'b0

module tsmc_rom_8kbyte ( Q, ADR, OE, ME, CLK);

parameter PreloadFilename = "/home/icdesign/work_fc/syn_180/emb/dummy.hex";

output  [31:0] Q;
input  [12:0] ADR;
input OE;
input ME;
input CLK;


parameter MES_ALL = "ON";

// Local registers, wires, etc

reg notif_adr;
reg notif_me;
reg notif_clk;

wire OE_eff;
wire OE_del;
reg ADRFLAGA;
wire CHKEN1A;
wire CHKEN2A; 
wire CHKEN3A;
wire CHKEN5A; 
wire CHKEN7A; 
reg chk_tmp0;   
wire [31:0] Q_buf;
wire [12:0] ADR_buf;
buf (ADR_buf[0], ADR[0]);
buf (ADR_buf[1], ADR[1]);
buf (ADR_buf[2], ADR[2]);
buf (ADR_buf[3], ADR[3]);
buf (ADR_buf[4], ADR[4]);
buf (ADR_buf[5], ADR[5]);
buf (ADR_buf[6], ADR[6]);
buf (ADR_buf[7], ADR[7]);
buf (ADR_buf[8], ADR[8]);
buf (ADR_buf[9], ADR[9]);
buf (ADR_buf[10], ADR[10]);
buf (ADR_buf[11], ADR[11]);
buf (ADR_buf[12], ADR[12]);
buf (OE_buf, OE);
buf (ME_buf, ME);
buf (CLK_buf, CLK);

initial
begin   : initl_blk
    $readmemh( PreloadFilename, uut.mem_core_array);
  ADRFLAGA = 1;
end     // end of initl_blk
buf #0.001 u_OE_del_0 ( OE_del, OE_eff );
bufif1 u_Q_0 (Q[0], Q_buf[0], OE_del);
bufif1 u_Q_1 (Q[1], Q_buf[1], OE_del);
bufif1 u_Q_2 (Q[2], Q_buf[2], OE_del);
bufif1 u_Q_3 (Q[3], Q_buf[3], OE_del);
bufif1 u_Q_4 (Q[4], Q_buf[4], OE_del);
bufif1 u_Q_5 (Q[5], Q_buf[5], OE_del);
bufif1 u_Q_6 (Q[6], Q_buf[6], OE_del);
bufif1 u_Q_7 (Q[7], Q_buf[7], OE_del);
bufif1 u_Q_8 (Q[8], Q_buf[8], OE_del);
bufif1 u_Q_9 (Q[9], Q_buf[9], OE_del);
bufif1 u_Q_10 (Q[10], Q_buf[10], OE_del);
bufif1 u_Q_11 (Q[11], Q_buf[11], OE_del);
bufif1 u_Q_12 (Q[12], Q_buf[12], OE_del);
bufif1 u_Q_13 (Q[13], Q_buf[13], OE_del);
bufif1 u_Q_14 (Q[14], Q_buf[14], OE_del);
bufif1 u_Q_15 (Q[15], Q_buf[15], OE_del);
bufif1 u_Q_16 (Q[16], Q_buf[16], OE_del);
bufif1 u_Q_17 (Q[17], Q_buf[17], OE_del);
bufif1 u_Q_18 (Q[18], Q_buf[18], OE_del);
bufif1 u_Q_19 (Q[19], Q_buf[19], OE_del);
bufif1 u_Q_20 (Q[20], Q_buf[20], OE_del);
bufif1 u_Q_21 (Q[21], Q_buf[21], OE_del);
bufif1 u_Q_22 (Q[22], Q_buf[22], OE_del);
bufif1 u_Q_23 (Q[23], Q_buf[23], OE_del);
bufif1 u_Q_24 (Q[24], Q_buf[24], OE_del);
bufif1 u_Q_25 (Q[25], Q_buf[25], OE_del);
bufif1 u_Q_26 (Q[26], Q_buf[26], OE_del);
bufif1 u_Q_27 (Q[27], Q_buf[27], OE_del);
bufif1 u_Q_28 (Q[28], Q_buf[28], OE_del);
bufif1 u_Q_29 (Q[29], Q_buf[29], OE_del);
bufif1 u_Q_30 (Q[30], Q_buf[30], OE_del);
bufif1 u_Q_31 (Q[31], Q_buf[31], OE_del);
    
specify
  specparam PATHPULSE$OE$Q = ( 0, 0.001 );
specparam

  Tac = 0.350,
  Tcax = 0.293,
  Tmc = 0.350,
  Tcmx = 0.000,
  Tcl = 0.528,
  Tch = 0.269,
  Tcc = 5.757,
  Tcq = 4.425,
  Tcqx = 1.742,
  Toq = 0.455,
  Toqz = 0.455;

  if (  OE  )
  ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
  if (  OE  )
  ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
       ( OE =>  Q[0] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[1] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[2] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[3] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[4] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[5] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[6] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[7] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[8] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[9] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[10] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[11] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[12] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[13] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[14] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[15] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[16] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[17] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[18] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[19] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[20] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[21] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[22] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[23] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[24] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[25] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[26] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[27] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[28] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[29] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[30] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );
       ( OE =>  Q[31] ) = (  Toq, Toq, Toqz, Toq, Toqz, Toq );

// Timing Checks

  $width (negedge CLK, Tcl, 0, notif_clk);
  $width (posedge CLK, Tch, 0, notif_clk);
  $period (posedge CLK, Tcc, notif_clk);
  $period (negedge CLK, Tcc, notif_clk);
  $hold (posedge CLK  &&& ME, posedge ADR[0], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[0], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[1], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[1], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[2], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[2], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[3], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[3], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[4], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[4], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[5], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[5], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[6], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[6], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[7], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[7], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[8], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[8], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[9], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[9], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[10], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[10], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[11], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[11], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, posedge ADR[12], Tcax, notif_adr );
  $hold (posedge CLK  &&& ME, negedge ADR[12], Tcax, notif_adr );
  $setup ( posedge ADR[0],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[0],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[1],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[1],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[2],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[2],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[3],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[3],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[4],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[4],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[5],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[5],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[6],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[6],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[7],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[7],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[8],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[8],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[9],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[9],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[10],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[10],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[11],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[11],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( posedge ADR[12],posedge CLK  &&& ME, Tac, notif_adr );
  $setup ( negedge ADR[12],posedge CLK  &&& ME, Tac, notif_adr );
  $hold (posedge CLK  &&& CHKEN2A, posedge ME, Tcmx, notif_me );
  $hold (posedge CLK  &&& CHKEN2A, negedge ME, Tcmx, notif_me );
  $setup ( posedge ME,posedge CLK  &&& CHKEN2A, Tmc, notif_me );
  $setup ( negedge ME,posedge CLK  &&& CHKEN2A, Tmc, notif_me );

endspecify



IntComp_tsmc_rom_8kbyte #(MES_ALL) uut (  Q_buf, ADR_buf, OE_buf, ME_buf, CLK_buf,notif_adr, notif_me, notif_clk );

and u_OE_0 (OE_eff, OE_buf, 1'b1);
    
always @( posedge CLK_buf )
begin
  ADRFLAGA = 1;
end

always @ ( ADR_buf )
begin :  ADR_buf_blk
  if ( $realtime != 0)
  begin // if  $realtime != 0
    if (( ADR_buf > 8191) || (ADR_buf < 0 ))
    ADRFLAGA = 0;
    else
    ADRFLAGA = 1;
  end    // end of if $realtime != 0
end     //  end of ADR_buf_blk
and u_CHKEN1A_0 ( CHKEN1A, ME_buf, ADRFLAGA);
buf u_CHKEN3A_0 ( CHKEN3A, ME_buf );
 
buf u_CHKEN2A_0 ( CHKEN2A, ADRFLAGA );

endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 



module IntComp_tsmc_rom_8kbyte (  Q, ADR, OE, ME, CLK,notif_adr, notif_me, notif_clk );

parameter MES_ALL = "ON";
parameter words = 8192, bits = 32, addrbits = 13, timingmode = 1;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input OE;
input ME;
input CLK;
input notif_adr, notif_me, notif_clk;


// Registers/Wires
reg    [31:0]  Q;
reg    [31:0]  Q_local_tmp;
reg    [31:0]  Q_local_prev;
reg [bits-1:0] mem_core_array [0:words-1];
reg
        flaga_read_ok,
        flaga_clk_ok,
        flaga_adr_ok;
reg     flaga_adr_x;
real    CLKA_T;
event   ev_read_out_a_port;
reg ME_chk;
reg [12:0] ADRlatched;
reg [12:0] ADR_old;
reg MElatched;
reg ME_old;


// TASK/FUNCTION DEFINITION
function is_adr_Valid;  // 1-bit return value
input [12:0] addr_to_check;
integer addr_bit_count;
reg     ret_value;
  begin
    ret_value = `True;
      for (addr_bit_count = 0; addr_bit_count <= 12; addr_bit_count = addr_bit_count +1)
        if ((addr_to_check[addr_bit_count] !== 1'b0) && (addr_to_check[addr_bit_count] !== 1'b1))
        begin
          flaga_adr_x = `True;
          ret_value = `False;
        end
      if((addr_to_check > 8191) || (addr_to_check < 0))
      begin
        ret_value = `False;
      end
   is_adr_Valid = ret_value;
  end
endfunction


// PORT A FUNCTIONALITY 
initial  
begin 
  flaga_adr_ok  = `False; 
  flaga_read_ok = `False;
  flaga_clk_ok = `False;
  flaga_adr_x = `False;
end

always @( negedge CLK or ADR )
 begin
   if ( CLK == 1'b0 )
     ADR_old = ADR;
 end

always @( negedge CLK or ME )
 begin
   if ( CLK == 1'b0 )
     ME_old = ME;
 end


always @(notif_clk)           
begin    //CLK violation
  disable OUTPUT;
  flaga_read_ok = `False;    
  -> ev_read_out_a_port; 
end
always @(notif_me)      
begin     //ME violation	
  disable OUTPUT;
  flaga_read_ok = `False;
   -> ev_read_out_a_port;
end

always @(notif_adr)           
begin    //ADR violation 
  if ( $realtime == CLKA_T )
    ME_chk = ME;
  else
    ME_chk = MElatched;
  if (ME_chk !== 1'b0)
  begin
    flaga_adr_ok = `False;
    flaga_read_ok = `False; 
    disable OUTPUT;
    -> ev_read_out_a_port;
  end
end


 

always @(negedge CLK)          // reset for next cycle
begin    // negedge CLK
  if ( CLK !== 1'bx )
  begin
    #0.001;
    flaga_adr_ok  = `True;
    flaga_read_ok = `True;
    flaga_clk_ok = `True;
    flaga_adr_x = `False;
  end
  else
  begin
    if( MES_ALL=="ON" && $realtime != 0)
    begin
      $display("<<CLK unknown>>");
      $display("      time=%t; instance=%m (tsmc_rom_8kbyte_core)",$realtime);
    end  
    flaga_clk_ok = `False;
      Q_local_tmp = 32'bx;
  end

end

// PORT A FUNCTIONALITY 
always @(posedge CLK)
begin    // posedge CLK 
  #0;
  CLKA_T = $realtime;
  MElatched = ME_old;
  ADRlatched = ADR_old;
  if (!flaga_clk_ok)
    Q_local_tmp = 32'bx;
  else if ( CLK === 1'bx )
  begin
    flaga_clk_ok = `False;
    Q_local_tmp = 32'bx;
  end
  else
  begin
    if (MElatched !== 1'b0)
    begin
        if (is_adr_Valid(ADRlatched) != `True )
        begin
            if( MES_ALL=="ON" && $realtime != 0)
            begin
              if ( flaga_adr_x )
              begin
                  $display("<<ADR unknown>>");
                 $display("      time=%t; instance=%m (tsmc_rom_8kbyte_core)",$realtime);
              end
            end
        flaga_adr_ok = `False;
        end
        if(((ADRlatched > 8191)|| ( ADRlatched < 0)) && (MElatched != 1'b0))
          $display("\n%m WARNING:address is out of range\n RANGE:0 to 8191\n");
          if ( MElatched === 1'bx ) 
          begin
              if( MES_ALL=="ON" && $realtime != 0)
              begin
                  $display("<<ME unknown>>");
                 $display("      time=%t; instance=%m (tsmc_rom_8kbyte_core)",$realtime);
              end
            Q_local_tmp = 32'bx;
          end
        else
        begin
        -> ev_read_out_a_port;
        end
    end
  end
end

always @(ev_read_out_a_port)
begin    // PORT A READ-OUT
  #0;     // let CLOCK and NOTIFIER module execute first
  if (flaga_adr_ok && (ADRlatched <= 8191) && flaga_read_ok)
  begin : OUTPUT
    Q_local_tmp = 32'bx;
    #0.001
    Q_local_tmp = mem_core_array[ADRlatched];
  end
  else
  begin
    Q_local_tmp = 32'bx;
    flaga_read_ok = `True;
  end
    Q_local_prev = Q_local_tmp;
end

always @( Q_local_tmp or OE )
begin
  if ( OE == 1'b1 )
    Q = Q_local_tmp;
  else if ( OE == 1'b0 )
  begin
    Q = 32'bx;
    #0.001;
    if ( OE == 1'b1 )
      Q = Q_local_tmp;
    else
      Q = 32'bz;
  end
  else
    Q = 32'bx;
end

always @( OE )
begin
  if ( OE ===  1'bx )
  begin
      if( MES_ALL=="ON" && $realtime != 0)
      begin
          $display("<<OE unknown>>");
          $display("      time=%t; instance=%m (tsmc_rom_8kbyte_core)",$realtime);
      end
  end
end 


endmodule
