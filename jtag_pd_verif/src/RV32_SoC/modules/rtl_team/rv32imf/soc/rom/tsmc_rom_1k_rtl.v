//---------------------------------------------------------------------
//               Copyright(c) Synopsys, Inc.                           
//     All Rights reserved - Unpublished -rights reserved under        
//     the Copyright laws of the United States of America.             
//                                                                     
//  U.S. Patents: 7,093,156 B1 and 7,406,620 B2 (and more pending).    
//                                                                     
//  This file includes the Confidential information of Synopsys, Inc.  
//  and TSMC.                                                          
//  The receiver of this Confidential Information shall not disclose   
//  it to any third party and shall protect its confidentiality by     
//  using the same degree of care, but not less than a reasonable      
//  degree of care, as the receiver uses to protect receiver's own     
//  Confidential Information.                                          
//  Licensee acknowledges and agrees that all output generated for     
//  Licensee by Synopsys, Inc. as described in the pertinent Program   
//  Schedule(s), or generated by Licensee through use of any Compiler  
//  licensed hereunder contains information that complies with the     
//  Virtual Component Identification Physical Tagging Standard (VCID)  
//  as maintained by the Virtual Socket Interface Alliance (VSIA).     
//  Such information may be expressed in GDSII Layer 63 or other such  
//  layer designated by the VSIA, hardware definition languages, or    
//  other formats.  Licensee is not authorized to alter or change any  
//  such information.                                                  
//---------------------------------------------------------------------
//                                                                     
//  Built for linux64 and running on linux64.                          
//                                                                     
//  Software           : Rev: W-2025.03                                
//  Library Format     : Rev: 1.05.00                                  
//  Compiler Name      : ts18s1p10v2sb02p2                             
//  Platform           : Linux3.10.0-1160.119.1.el7.x86_64             
//                     : #1 SMP Tue Jun 4 14:43:51 UTC 2024x86_64      
//  Date of Generation : Mon Apr 07 14:28:50 PKT 2025                  
//                                                                     
//---------------------------------------------------------------------
//   --------------------------------------------------------------     
//                       Template Revision : 2.0.4                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port ROM *                   
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:tsmc_rom_1k                                          
//   Memory Size:256 words x 32 bits                                  
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[31:0]                          
//               Input Ports:                                         
//                                   ADR[7:0]                         
//                                   OE                               
//                                   ME                               
//                                   CLK                              


`resetall 

`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 
`delay_mode_path 


`define True    1'b1
`define False   1'b0

module tsmc_rom_1k ( Q, ADR, OE, ME, CLK);
parameter PreloadFilename = "/home/qamar/Desktop/RivRtos/src/tb/rom.hex";
parameter MES_ALL = "ON";

output  [31:0] Q;
input  [7:0] ADR;
input OE;
input ME;
input CLK;


// Local registers, wires, etc

wire OE_buf;
assign OE_buf =  OE;
wire ME_buf;
assign ME_buf =  ME;

generic_tsmc_rom_1k uut ( Q,ADR,OE_buf,ME_buf,CLK );

endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 



module generic_tsmc_rom_1k ( Q, ADR, OE, ME, CLK);

parameter words = 256, I_bit = 32, I_word = 256, bits = 32, addrbits = 8, PreloadFilename = "/home/qamar/Desktop/RivRtos/src/tb/rom.hex", timingmode = 1;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input OE;
input ME;
input CLK;


parameter MES_ALL = "ON";

reg [bits-1:0] QI;
reg [bits-1:0] Q;
reg oldCLK;
reg [bits-1:0] allX , allZ ;
real OUT_risetime;
reg [bits-1:0] mem_core_array [0:words-1];

integer i,j;

reg [addrbits-1:0] ADRlatched;

reg [addrbits-1:0] ADR_old;

reg MElatched;
reg ME_old;

//-- Initialization Valiable
initial
begin   
  $timeformat (-9,3," ns",8);
   for ( i=0; i < I_bit ; i=i+1 )
   begin
     allX[i] = 1'bx ; allZ[i] = 1'bz ;
   end
       $readmemh ( PreloadFilename, mem_core_array);
end 

//====< port >====
//-- port Data Output
always @ ( OE or QI )
begin
  if( OE )
  begin
    Q <= QI;
  end
  else if( !OE )
  begin
    Q <= allZ;
  end
  else if( OE===1'bx )
  begin
      if( MES_ALL=="ON" && CLK===1'b1 && OUT_risetime !=$realtime && $realtime != 0) 
      begin
          $display("<<OE unknown>>");
          $display("      time=%t; instance=%m (ROM)",$realtime);
      end
    Q <= allX;
  end
    OUT_risetime <= $realtime;
end

always @( negedge CLK or ADR )
begin
  if ( CLK == 1'b0 )
    ADR_old = ADR;
end
always @( negedge CLK or ME )
begin
  if ( CLK == 1'b0 )
    ME_old = ME;
end

always @( posedge CLK )
begin     //Internal Data Set
  oldCLK <= CLK;
  MElatched = ME_old;
  ADRlatched = ADR_old;
  if( CLK===1'bx )
  begin    //CLK="0->X"
    if( MES_ALL=="ON" )
    begin
      $display("<<CLK unknown>>");
      $display("      time=%t; instance=%m (ROM)",$realtime);
    end 
    QI <= allX;
  end
  else if( oldCLK===1'bx && CLK===1'b1 )
  begin
    QI <= allX;
  end
  else if ( MElatched === 1'bx )
  begin
      if( MES_ALL=="ON" )
      begin
          $display("<<ME unknown>>");
          $display("      time=%t; instance=%m (ROM)",$realtime);
      end
    QI <= allX;
  end
  else if( MElatched )
  begin    //ME=1
    if ( ^ADRlatched === 1'bx )
    begin
        if( MES_ALL=="ON" )
        begin
            $display("<<ADR unknown>>"); 
           $display("      time=%t; instance=%m (ROM)",$realtime); 
        end 
      QI <= allX;
    end
    else if ( ADRlatched < 0 || ADRlatched > I_word ) 
    begin
      if( MES_ALL=="ON" )
      begin
        $display("<<ADR out of range>>");
        $display("      time=%t; instance=%m (ROM)",$realtime);
      end
      QI <= allX;
    end
    else if ( ^ADRlatched !== 1'bx && ADRlatched <  I_word )
    begin
      QI <= mem_core_array[ADRlatched];
    end
  end
end
//---- Clock Negative Edge
always @( negedge CLK )
begin
  oldCLK <= CLK;
  if( oldCLK===1'b1 && CLK===1'bx )
  begin
    if( MES_ALL=="ON" )
    begin
      $display("<<CLK unknown>>");
      $display("      time=%t; instance=%m (ROM)",$realtime);
    end
    QI <= allX;
  end
end


endmodule
